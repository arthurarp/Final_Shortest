{"version":3,"sources":["pages/Home/styles.js","pages/Home/index.js","functions/graph.js","routes.js","styles/global.js","App.js","index.js"],"names":["Container","styled","div","Header","Body","Menu","darken","Text","p","SubText","SubTextInstructions","Conditional","Bottom","GraphContainer","FormContainer","Input","input","graph","this","vertexs","memoization","totalNodes","sucessor","solutionSet","id","vertex","neighbors","degree","origin","destiny","weight","type","new_edge","new_inverse_edge","i","Number","MAX_SAFE_INTEGER","edge","aux","console","log","hasOwnProperty","path","push","cost","Home","useState","renderizedGraph","setRenderizedGraph","setTotalNodes","destinyInput","setDestinyInput","setPath","setCost","example","setExample","applied","setApplied","setLastValid","events","select","event","nodes","edges","length","getVertex","response","findSolution","alert","ApplyButton","renderized","j","from","to","setTimeout","drawPath","renderize","time","is_user","index","new_renderized","renderGraph","currentNode","shortestPath","converter","new_node","label","title","toString","color","clear","random","addVertex","addEdge","getTotalVertex","exampleOne","exampleTwo","onClick","target","value","required","onChange","placeholder","options","Routes","exact","component","createGlobalStyle","App","basename","render","document","getElementById"],"mappings":"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","file":"static/js/main.fa418ab9.chunk.js","sourcesContent":["import styled from \"styled-components\";\nimport { darken } from \"polished\";\nexport const Container = styled.div`\n  height: 100%;\n  background: linear-gradient(-90deg, #c9c9c9, #000);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n`;\nexport const Header = styled.div`\n  height: 10%;\n  width: 100%;\n  flex-direction: column;\n  vertical-align: middle;\n  background: #000;\n  justify-content: center;\n  align-items: center;\n  display: flex;\n`;\nexport const Body = styled.div`\n  height: 100%;\n  width: 100%;\n  display: flex;\n  align-items: center;\n  flex-direction: row;\n`;\nexport const Menu = styled.div`\n  height: 100%;\n  width: 20%;\n  display: flex;\n  background: #000;\n  align-items: center;\n  flex-direction: column;\n  button {\n    margin: 15px;\n    padding: 10px;\n    height: 12%;\n    width: 60%;\n    background: #FFF;\n    font-weight: bold;\n    color: #000;\n    border: 0;\n    border-radius: 4px;\n    font-size: 16px;\n    transition: background 0.2s;\n    &:hover {\n      background: ${darken(0.03, \"#3b9eff\")};\n    }\n  }\n  textAlign = center;\n`;\nexport const Text = styled.p`\n  font-size: 30px;\n  color: #fff;\n  text-align: center;\n`;\nexport const SubText = styled.p`\n  font-size: 30px;\n  color: #ff0;\n  text-align: center;\n`;\nexport const SubTextInstructions = styled.p`\n  margin-top: 15px;\n  font-size: 20px;\n  color: #ff0000;\n  text-align: center;\n`;\nexport const Conditional = styled.div`\n  height: 100%;\n  width: 100%;\n  display: flex;\n  align-items: center;\n  flex-direction: column;\n`;\n\nexport const Bottom = styled.div`\n  height: 10%;\n  width: 100%;\n  flex-direction: row;\n  justify-content: space-evenly;\n  align-items: center;\n  background: #000;\n  display: flex;\n`;\n\nexport const GraphContainer = styled.div`\n  height: 100%;\n  width: 80%;\n  display: flex;\n`;\n\nexport const FormContainer = styled.div`\n  height: 100%;\n  width: 100%;\n  display: flex;\n  align-items: center;\n  flex-direction: column;\n  form {\n    display: flex;\n    flex-direction: column;\n    margin-top: 30px;\n    button {\n      margin: 15px;\n      padding: 10px;\n      height: 12%;\n      width: 60%;\n      background: linear-gradient(-90deg, #fff, #000);\n      font-weight: bold;\n      color: #fff;\n      border: 0;\n      border-radius: 4px;\n      font-size: 16px;\n      transition: background 0.2s;\n      &:hover {\n        background: ${darken(0.03, \"#3b9eff\")};\n      }\n    }\n`;\n\nexport const Input = styled.input`\n  background: rgba(0, 0, 0, 0.1);\n  border: 1;\n  border-color: #fff;\n  border-radius: 4px;\n  height: 35px;\n  padding: 0 15px;\n  color: #fff;\n  margin: 0 0 10px;\n  &::placeholder {\n    color: rgba(255, 255, 255, 0.7);\n  }\n`;\n","import React, { useEffect, useState } from \"react\";\nimport { Form } from \"@rocketseat/unform\";\nimport Graph from \"react-graph-vis\";\nimport {\n  Container,\n  Header,\n  Body,\n  Menu,\n  Text,\n  Bottom,\n  SubText,\n  Conditional,\n  FormContainer,\n  Input,\n  SubTextInstructions,\n  GraphContainer,\n} from \"./styles\";\nimport options from \"../../jsons/options.json\";\nimport exampleOne from \"../../jsons/example1.json\";\nimport exampleTwo from \"../../jsons/example2.json\";\nimport random from \"../../jsons/random.json\";\nimport GraphStructure from \"../../functions/graph\";\n\nconst graph = new GraphStructure();\nfunction Home() {\n  const [renderizedGraph, setRenderizedGraph] = useState(null);\n  const [totalNodes, setTotalNodes] = useState(0);\n  const [destinyInput, setDestinyInput] = useState(\"\");\n  const [path, setPath] = useState([]);\n  const [cost, setCost] = useState(0);\n  const [example, setExample] = useState(0);\n  const [applied, setApplied] = useState(false);\n  const [lastValid, setLastValid] = useState(\"\");\n  const [memoization, setMemoization] = useState(\"\");\n\n  const events = {\n    // função que captura os nós selecionados pelo usuario\n    select: function (event) {\n      var { nodes, edges } = event;\n\n      // se nao tiver vertice selecionado ou o input vazio, retorna\n      if (\n        nodes.length == 0 ||\n        destinyInput == \"\" ||\n        !graph.getVertex().hasOwnProperty(destinyInput) ||\n        !applied\n      ) {\n        return;\n      }\n      if (destinyInput && nodes[0]) {\n        let response = graph.findSolution(nodes[0], destinyInput);\n        if (response == -1) {\n          alert(\"Não existe caminho!\");\n        } else if (response == -2) {\n          alert(\"Origem e destino iguais! Custo = 0\");\n          ApplyButton();\n          setCost(0);\n        } else {\n          ApplyButton();\n          setPath(response.path);\n          setCost(response.cost);\n          drawPath(response.path);\n        }\n      }\n    },\n  };\n  function renderize(graph, time) {\n    setRenderizedGraph(null);\n    setTimeout(() => {\n      setRenderizedGraph(graph);\n    }, time);\n  }\n\n  function ApplyButton(is_user) {\n    if (destinyInput == \"\") {\n      alert(\"Insira um vértice no campo 'Vértice Destino'\");\n      return;\n    }\n    setApplied(true);\n\n    if (!graph.getVertex().hasOwnProperty(destinyInput)) {\n      let response = \"Vertice '\" + destinyInput + \"' não existente!\";\n      alert(response);\n      setApplied(false);\n      setDestinyInput(\"\");\n      return;\n    }\n    setLastValid(destinyInput);\n\n    let new_renderized = renderGraph(example, 0);\n    let index;\n    let currentNode = destinyInput;\n    //if (is_user === 1) {\n    // acha todas as soluções pro nó passado\n\n    graph.shortestPath(destinyInput);\n    if (is_user === 1) console.log('memoization', graph.memoization);\n    //}\n    // achando o nó escolhido pelo usuario e mudando a cor dele no grafo\n    for (let i = 0; i < new_renderized.nodes.length; ++i) {\n      if (new_renderized.nodes[i].id === currentNode) {\n        index = i;\n      }\n    }\n    new_renderized.nodes[index][\"color\"] = \"#91c095\";\n\n    // renderizando com a cor alterada\n    renderize(new_renderized, 25);\n    return new_renderized;\n  }\n  function converter() {\n    let nodes = [];\n    let edges = [];\n\n    for (let vertex in graph.vertexs) {\n      let new_node = {\n        id: vertex,\n        label: vertex,\n        title: \"node 1\",\n      };\n      nodes.push(new_node);\n\n      for (let edge in graph.vertexs[vertex].neighbors) {\n        let new_edge = {\n          from: graph.vertexs[vertex].neighbors[edge].origin,\n          to: graph.vertexs[vertex].neighbors[edge].destiny,\n          label: graph.vertexs[vertex].neighbors[edge].weight.toString(),\n          color: \"#FF0\",\n        };\n        edges.push(new_edge);\n      }\n    }\n\n    return {\n      nodes: nodes,\n      edges: edges,\n    };\n  }\n\n  function renderGraph(id, is_user) {\n    if (is_user) {\n      setApplied(false);\n      setDestinyInput(\"\");\n      setCost(0);\n    }\n    if (id == 0) {\n      graph.clear(); // zerando a estrutura\n\n      for (let vertex of random.nodes) {\n        graph.addVertex(vertex.id);\n      }\n      for (let edge of random.edges) {\n        graph.addEdge(edge.origin, edge.destiny, edge.weight);\n      }\n      let new_renderized = converter();\n\n      setRenderizedGraph(null);\n      setExample(id);\n      setTotalNodes(graph.getTotalVertex());\n      renderize(new_renderized, 50);\n\n      return new_renderized;\n    } else if (id == 1) {\n      graph.clear(); // zerando a estrutura\n\n      // carregando o grafo de um arquivo externo\n      for (let vertex of exampleOne.nodes) {\n        graph.addVertex(vertex.id);\n      }\n      for (let edge of exampleOne.edges) {\n        graph.addEdge(edge.origin, edge.destiny, edge.weight);\n      }\n\n      // renderizando na tela\n      let new_renderized = converter();\n\n      setRenderizedGraph(null);\n      setExample(id);\n      setTotalNodes(graph.getTotalVertex());\n      renderize(new_renderized, 50);\n\n      return new_renderized;\n    } else if (id == 2) {\n      graph.clear();\n      for (let vertex of exampleTwo.nodes) {\n        graph.addVertex(vertex.id);\n      }\n      for (let edge of exampleTwo.edges) {\n        graph.addEdge(edge.origin, edge.destiny, edge.weight);\n      }\n\n      // renderizando na tela\n      let new_renderized = converter();\n\n      setRenderizedGraph(null);\n      setExample(id);\n      setTotalNodes(graph.getTotalVertex());\n      renderize(new_renderized, 50);\n\n      return new_renderized;\n    }\n  }\n\n  function drawPath(path) {\n    let renderized = ApplyButton(example);\n    for (let i = 0; i < path.length; ++i) {\n      for (let j = 0; j < totalNodes; ++j) {\n        if (renderized.nodes[j].id == path[i]) {\n          if (i == 0) {\n            renderized.nodes[j][\"color\"] = \"#c397c0\";\n          } else if (i == path.length - 1) {\n            renderized.nodes[j][\"color\"] = \"#91c095\";\n          } else {\n            renderized.nodes[j][\"color\"] = \"#a4609e\";\n          }\n        }\n      }\n    }\n\n    for (let i = 0; i < path.length - 1; ++i) {\n      for (let edge in renderized.edges) {\n        if (\n          renderized.edges[edge].from == path[i] &&\n          renderized.edges[edge].to == path[i + 1]\n        ) {\n          renderized.edges[edge][\"color\"] = \"#a4609e\";\n        }\n      }\n    }\n    console.log(path);\n    setRenderizedGraph(null);\n    setTimeout(() => {\n      setRenderizedGraph(renderized);\n    }, 150);\n  }\n\n  return (\n    <Container>\n      <Header>\n        <Text>Menor Caminho</Text>\n      </Header>\n      <Body>\n        <Menu>\n          <Text>Menu</Text>\n          <button id=\"0\" onClick={(id) => renderGraph(id.target.id, 1)}>\n            Grafo Aleatório\n          </button>\n          <button id=\"1\" onClick={(id) => renderGraph(id.target.id, 1)}>\n            Exemplo 1 - Aula\n          </button>\n\n          <button id=\"2\" onClick={(id) => renderGraph(id.target.id, 1)}>\n            Exemplo 2 - Aula\n          </button>\n\n          {renderizedGraph ? (\n            <Conditional>\n              <FormContainer>\n                {applied ? (\n                  <SubTextInstructions>\n                    Clique em algum vértice, do grafo ao lado, para saber o\n                    menor caminho\n                  </SubTextInstructions>\n                ) : (\n                  <SubTextInstructions>\n                    Abaixo selecione um vértice de destino\n                  </SubTextInstructions>\n                )}\n                <Form>\n                  <Input\n                    value={destinyInput}\n                    required\n                    onChange={(input) => {\n                      setDestinyInput(input.target.value);\n                    }}\n                    placeholder=\"Vértice Destino\"\n                  />\n                </Form>\n                <button type=\"submit\" onClick={() => ApplyButton(1)}>\n                  Aplicar\n                </button>\n              </FormContainer>\n            </Conditional>\n          ) : (\n            <SubTextInstructions>\n              Primeiro renderize um dos grafos acima\n            </SubTextInstructions>\n          )}\n        </Menu>\n        {renderizedGraph ? (\n          <GraphContainer>\n            <Graph graph={renderizedGraph} options={options} events={events} />\n          </GraphContainer>\n        ) : null}\n      </Body>\n      <Bottom>\n        <SubText>Número de Vértices: {totalNodes}</SubText>\n        <SubText>Menor Custo Total: {cost}</SubText>\n      </Bottom>\n    </Container>\n  );\n}\nexport default Home;\n","export default class Graph {\n  constructor() {\n    this.vertexs = {}; // implementado assim para poder achar qualquer nó em O(1) (passando o id)\n    this.memoization = {};\n    this.totalNodes = 0;\n    this.sucessor = {};\n    this.solutionSet = {};\n  }\n\n  // adição de um vertice 'id' no grafo\n  addVertex(id) {\n    let vertex = {\n      id: id,\n      neighbors: {}, // implementado assim para poder achar qualquer nó vizinho em O(1) (passando o id)\n      degree: 0,\n    };\n\n    this.vertexs[id] = vertex;\n    this.totalNodes++;\n  }\n\n  // OBS: parametro 'type' opcional (se nao for passado ele considera uma aresta orientada (a->c))\n  // se for passado o valor 'undirected' em 'type', ele alem de fazer a aresta (a->c) ele faz a aresta (c->a)\n  addEdge(origin, destiny, weight, type) {\n    let new_edge = {\n      origin: origin,\n      destiny: destiny,\n      weight: weight,\n    };\n    this.vertexs[origin][\"neighbors\"][destiny] = new_edge;\n    this.vertexs[origin][\"degree\"]++;\n\n    if (type === \"undirected\") {\n      let new_inverse_edge = {\n        origin: destiny,\n        destiny: origin,\n        weight: weight,\n      };\n\n      this.vertexs[destiny][\"neighbors\"][origin] = new_inverse_edge;\n      this.vertexs[destiny][\"degree\"]++;\n    }\n  }\n\n  getVertex() {\n    return this.vertexs;\n  }\n\n  getTotalVertex() {\n    return this.totalNodes;\n  }\n\n  clear() {\n    this.vertexs = {};\n    this.memoization = {};\n    this.totalNodes = 0;\n    this.sucessor = {};\n    this.solutionSet = {};\n  }\n\n  shortestPath(destiny) {\n    // iniciar com infinito e zerar somente a coluna do nó destiny\n    for (let i = 0; i < this.totalNodes; ++i) {\n      this.memoization[i] = {}; // criando objeto para cada iteração\n      for (let vertex in this.vertexs) {\n        this.memoization[i][vertex] = Number.MAX_SAFE_INTEGER; // recebendo valor \"infinito\"\n      }\n      this.memoization[i][destiny] = 0; // zerando a coluna do nó procurado, pois para chegar a ele precisamos de 0 arestas.\n    }\n\n    // loops para verificar os menores caminhos (logica do algoritmo)\n\n    // ----------------------------------------------------------- //\n    for (let i = 1; i <= this.totalNodes - 1; ++i) {\n      for (let vertex in this.vertexs) {\n        this.memoization[i][vertex] = this.memoization[i - 1][vertex]; // o valor atual recebe o mesmo valor da coluna acima\n        // para cada vizinho do nó\n        for (let edge in this.vertexs[vertex].neighbors) {\n          // o if abaixo verifica se os 2 valores sao infinitos, se sim, vai pra proxima iteração.\n          if (\n            this.memoization[i][vertex] === Number.MAX_SAFE_INTEGER &&\n            this.memoization[i - 1][edge] === Number.MAX_SAFE_INTEGER\n          ) {\n            continue;\n          }\n          // o if abaixo verifica se o valor atual e maior que o valor do vizinho na linha de cima + o peso desse vizinho\n          if (\n            this.memoization[i][vertex] >\n            this.memoization[i - 1][edge] +\n              this.vertexs[vertex].neighbors[edge].weight\n          ) {\n            //se sim faz o swap, e adiciona o sucessor.\n            this.memoization[i][vertex] =\n              this.memoization[i - 1][edge] +\n              this.vertexs[vertex].neighbors[edge].weight;\n            this.sucessor[vertex] = edge;\n          }\n        }\n      }\n    }\n\n    return this.memoization;\n    // ----------------------------------------------------------- //\n  }\n  // find solution\n  findSolution(origin, destiny) {\n    for (let vertex in this.vertexs) {\n      let aux = this.memoization[this.totalNodes - 1][vertex]; // salvando o valor do vertex atual na ultima iteração e salvando em aux\n      if (aux == Number.MAX_SAFE_INTEGER) {\n        // se o ultimo valor do vertex atual na ultima iteração for infinito, significa que nao existe aresta para o nó destino\n        //partin do de vertex, entao é adicionado null.\n        this.solutionSet[vertex] = null;\n        continue;\n      }\n      for (let i = this.totalNodes - 2; i >= 0; --i) {\n        // verificando até qual indice o valor permanece o mesmo para sabermos o menor numero de arestas\n        if (this.memoization[i][vertex] == aux) {\n          this.solutionSet[vertex] = i;\n        }\n      }\n    }\n\n    // find path\n    let aux = origin;\n    if (aux == destiny) {\n      console.log(\"Destino e origem iguais\");\n      return -2;\n    }\n    if (!this.sucessor.hasOwnProperty(origin)) {\n      console.log(\"Não existe um caminho entre \", origin, \" e \", destiny);\n      return -1;\n    }\n    let path = [];\n    while (aux != destiny) {\n      // procurando o caminho do nó origem até o destino;\n      path.push(aux);\n\n      let last = this.sucessor[aux];\n\n      aux = last;\n    }\n    path.push(aux);\n    let response = {\n      path: path,\n      cost: this.memoization[this.solutionSet[origin]][origin],\n    };\n    return response;\n  }\n}\n","import React from \"react\";\nimport { Switch, Route } from \"react-router-dom\";\nimport Home from \"./pages/Home\";\n\nexport default function Routes() {\n  return (\n    <Switch>\n      <Route path=\"/Final_Shortest/\" exact component={Home} />\n    </Switch>\n  );\n}\n","import { createGlobalStyle } from \"styled-components\";\nimport \"react-toastify/dist/ReactToastify.css\";\nimport \"react-perfect-scrollbar/dist/css/styles.css\";\n\nexport default createGlobalStyle`\n@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');\n*{\n  margin:0;\n  padding:0;\n  outline:0;\n  box-sizing:border-box;\n}\n*:focus{\n  outline:0;\n}\nhtml ,body, #root{\n  height:100%;\n}\nbody{\n  -webkit-font-smoothing:antialiased;\n}\nbody, -moz-user-input, button{\n  font :14px 'Roboto',sans-serif;\n}\na{\n  text-decoration:none;\n}\nul{list-style:none;}\nbutton{\n  cursor:pointer;\n}\n`;\n","import React from \"react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport Routes from \"./routes\";\nimport GlobalStyle from \"./styles/global\";\n\nfunction App() {\n  return (\n    <BrowserRouter basename=\"shortest\">\n      <Routes />\n      <GlobalStyle />\n    </BrowserRouter>\n  );\n}\nexport default App;\n","import React from \"react\";\nimport { render } from \"react-dom\";\nimport App from \"./App\";\nrender(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}